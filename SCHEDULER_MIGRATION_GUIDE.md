# Scheduler Migration Guide

## **Quick Start: Testing Optimized Scheduler**

### **Step 1: Add API Endpoint**

Add to `main.py`:

```python
# Add import
from api.scheduler_comparison import router as scheduler_comparison_router

# Register router
app.include_router(scheduler_comparison_router, prefix="/api", tags=["scheduler-comparison"])
```

### **Step 2: Start Server with BOTH Schedulers**

Option A: Parallel testing (safest):
```python
# In main.py startup event
@app.on_event("startup")
async def startup_event():
    # Start old scheduler
    await start_scheduler()
    
    # Start optimized scheduler (parallel testing)
    await start_optimized_scheduler()
```

Option B: Optimized only:
```python
# In main.py startup event
@app.on_event("startup")
async def startup_event():
    # Comment out old scheduler
    # await start_scheduler()
    
    # Start optimized scheduler only
    await start_optimized_scheduler()
```

### **Step 3: Test Unified Scan**

```bash
# Test with day trading + short selling
curl -X POST "http://localhost:8000/api/scheduler/test/unified-scan?categories=day_trading,short_selling"

# Response shows execution time and cache stats
{
  "success": true,
  "categories": ["day_trading", "short_selling"],
  "execution_time_seconds": 45.23,
  "cache_stats": {
    "total_cached_symbols": 22,
    "valid_cache_entries": 22,
    "symbols": ["RELIANCE", "TCS", ...]
  }
}
```

### **Step 4: Monitor Performance**

```bash
# Compare execution stats
curl "http://localhost:8000/api/scheduler/stats/comparison"

# Check cache performance
curl "http://localhost:8000/api/scheduler/cache/stats"

# Estimate API call savings
curl "http://localhost:8000/api/scheduler/api-calls/estimate"
```

---

## **Migration Phases**

### **Phase 1: Parallel Testing (Week 1)**

**Goal:** Run both schedulers, compare results

```python
# main.py
@app.on_event("startup")
async def startup_event():
    await start_scheduler()  # Old
    await start_optimized_scheduler()  # New
```

**Monitoring:**
- Compare signal counts for same symbols
- Check execution times
- Monitor API call rates
- Validate cache hit rates

**Success Criteria:**
- âœ… Same signals generated by both schedulers
- âœ… Optimized scheduler 50%+ faster
- âœ… No errors in optimized scheduler
- âœ… Cache hit rate > 60%

### **Phase 2: Gradual Cutover (Week 2-3)**

**Day 1-3: Day trading only**
```python
# Disable day trading in old scheduler
# services/scheduler.py - comment out day trading job
```

**Day 4-7: Add short selling**
```python
# Disable short selling in old scheduler
```

**Day 8-14: Add short term**
```python
# Disable short term in old scheduler
```

**Day 15-21: Full migration**
```python
# Stop old scheduler completely
await stop_scheduler()
```

### **Phase 3: Cleanup (Week 4)**

**Remove old code:**
```bash
# Backup old scheduler
mv services/scheduler.py services/scheduler_old.py.bak

# Rename optimized scheduler
mv services/optimized_scheduler.py services/scheduler.py
```

**Update imports:**
```python
# Update all files that import scheduler
# Old: from services.scheduler import get_scheduler
# New: from services.optimized_scheduler import get_optimized_scheduler
```

---

## **Configuration Options**

Add to `.env`:

```bash
# Optimized Scheduler Settings
SCHEDULER_MAX_CONCURRENT_SYMBOLS=5  # Process 5 symbols at once
SCHEDULER_CACHE_DURATION_MINUTES=30  # Cache valid for 30 minutes
SCHEDULER_ENABLE_PARALLEL_ANALYSIS=true  # Analyze all categories in parallel
SCHEDULER_LOG_CACHE_STATS=true  # Log cache hit rates
```

---

## **Rollback Plan**

If issues occur:

### **Immediate Rollback:**
```python
# In main.py startup
@app.on_event("startup")
async def startup_event():
    # Stop optimized scheduler
    # await start_optimized_scheduler()
    
    # Use old scheduler only
    await start_scheduler()
```

### **Partial Rollback:**
```python
# Keep both running but reduce optimized scheduler load
# Only run optimized scheduler for day trading
scheduler = get_optimized_scheduler()
scheduler.strategy_symbols = {
    StrategyCategory.DAY_TRADING: {'RELIANCE', 'TCS'}  # Limited symbols
}
```

---

## **Testing Checklist**

### **Before Migration:**
- [ ] Backup database
- [ ] Document current API call rates
- [ ] Record current execution times
- [ ] Test optimized scheduler on staging

### **During Migration:**
- [ ] Monitor error rates
- [ ] Compare signal counts
- [ ] Track API usage
- [ ] Check cache hit rates
- [ ] Validate telegram notifications still work

### **After Migration:**
- [ ] Verify all strategies running correctly
- [ ] Confirm 50%+ reduction in API calls
- [ ] Check execution times improved
- [ ] Remove old scheduler code
- [ ] Update documentation

---

## **Troubleshooting**

### **Issue: Cache not working**

**Check:**
```bash
curl "http://localhost:8000/api/scheduler/cache/stats"
```

**Fix:**
```python
# Clear cache and let it rebuild
curl -X POST "http://localhost:8000/api/scheduler/cache/clear"
```

### **Issue: Slow execution**

**Check concurrency:**
```python
# Increase parallel processing
SCHEDULER_MAX_CONCURRENT_SYMBOLS=10  # Process more symbols at once
```

### **Issue: Different signals than old scheduler**

**Validate data:**
```python
# Check if both fetch same historical data
old_data = await old_scheduler.data_fetcher.get_historical_data("RELIANCE", "1D", 30)
new_data = await new_scheduler.symbol_cache["RELIANCE"].historical_data

assert len(old_data) == len(new_data)
```

---

## **Performance Metrics to Track**

### **Key Metrics:**

1. **API Calls per Day**
   - Old scheduler: ~711 calls/day
   - Target: <350 calls/day
   - Monitor: IIFL API logs

2. **Execution Time**
   - Old scheduler: 15-20 min per strategy
   - Target: 5-8 min per unified scan
   - Monitor: `/api/scheduler/stats/comparison`

3. **Cache Hit Rate**
   - Target: >60% after warmup period
   - Monitor: `/api/scheduler/cache/stats`

4. **Signal Generation Rate**
   - Should match old scheduler Â±5%
   - Monitor: Database signal counts

5. **Error Rate**
   - Should be <1%
   - Monitor: Application logs

### **Dashboard Monitoring:**

```python
# Add to production_dashboard.py
@router.get("/api/dashboard/scheduler-metrics")
async def get_scheduler_metrics():
    scheduler = get_optimized_scheduler()
    
    return {
        "cache_hit_rate": calculate_cache_hit_rate(),
        "api_calls_today": count_api_calls_today(),
        "avg_execution_time": scheduler.get_execution_stats(),
        "signals_generated_today": count_signals_today()
    }
```

---

## **Expected Results**

### **Week 1 (Parallel Testing):**
- âœ… Both schedulers running
- âœ… Validate signal parity
- âœ… Measure performance gains
- âœ… Identify any issues

### **Week 2-3 (Gradual Cutover):**
- âœ… 50% API call reduction
- âœ… 60% faster execution
- âœ… 70% cache hit rate
- âœ… Zero downtime

### **Week 4 (Cleanup):**
- âœ… Old scheduler removed
- âœ… Code simplified
- âœ… Documentation updated
- âœ… Full optimization achieved

---

## **Success Criteria**

Migration is successful when:

1. âœ… **API calls reduced by 50%+**
2. âœ… **Execution time reduced by 60%+**
3. âœ… **Cache hit rate > 60%**
4. âœ… **Same or more signals generated**
5. âœ… **Zero production incidents**
6. âœ… **Telegram notifications working**
7. âœ… **All strategies running on schedule**

---

## **Next Steps**

1. **Today:** Add comparison API endpoints to main.py
2. **Tomorrow:** Start parallel testing (both schedulers)
3. **Week 1:** Monitor and validate performance
4. **Week 2:** Begin gradual cutover
5. **Week 3:** Complete migration
6. **Week 4:** Remove old code and celebrate! ðŸŽ‰

**Questions?** Check logs at `/var/log/trading_system/` or API endpoint `/api/scheduler/status`
